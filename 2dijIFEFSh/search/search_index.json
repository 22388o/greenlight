{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Greenlight a Blockstream project offering hosted, non-custodial, Lightning Network nodes to end-users. We take care of the infrastructure, while you are in control of the keys. Nodes can be registered and started in seconds, perfect for new users that are just starting their Bitcoin and Lightning Network journey, developers wanting to provide their users with access to the Lightning Network, or hobbyists wanting to hack tools for their own use. It is not our goal to capture users: once you've gained experience running a node, you can off-board into your own infrastructure, and we'll teach you how to do that too.","title":"Introduction"},{"location":"#introduction","text":"Greenlight a Blockstream project offering hosted, non-custodial, Lightning Network nodes to end-users. We take care of the infrastructure, while you are in control of the keys. Nodes can be registered and started in seconds, perfect for new users that are just starting their Bitcoin and Lightning Network journey, developers wanting to provide their users with access to the Lightning Network, or hobbyists wanting to hack tools for their own use. It is not our goal to capture users: once you've gained experience running a node, you can off-board into your own infrastructure, and we'll teach you how to do that too.","title":"Introduction"},{"location":"about/","text":"About","title":"About"},{"location":"about/#about","text":"","title":"About"},{"location":"getting-started/","text":"Overview Before diving into the specifics, let's first define a number of concepts that will be useful once we start developing: Nodes Greenlight provisions and manages Core Lightning nodes on behalf of its users. The nodes expose the grpc interface defined in the cln-grpc proto file , without limitations. The goal of this guide is to spin up a node and interact with it as if it were a local Core Lightning node. Authentication All communication channels in Greenlight are authenticated and encrypted via mTLS (mutual Transport Layer Security), similar to HTTPS in the browser. Each client receives its own identity in the form of a private key and matching certificate, which can then be used to authenticate and encrypt communication when talking with Greenlight. In this guide we will be using two identities: nobody : An identity that is shipped with the library, used to communicate with services that don't require authentication. A Device Identity: A unique identity used by the application to authenticate with the Greenlight. The private key is generated and kept locally, and certified by Greenlight to belong to a given node. See the security page for more details about how the authentication works. Signer The signer manages any private information, is used to prove node ownership when registering and recovering, and processes signature requests from the node. It is initialized with the secret seed (a 32 byte secret), the bitcoin network the node runs on, and the identity to use when communicating with the node. See the security page for details on how the signer ensures that operations it signs off originate from an authenticated app. Scheduler Node in Greenlight are scheduled on-demand when a client needs to talk to it. The Scheduler tracks which nodes are running where, and starts them if they aren't running yet. You can think of it as just a mechanism to register new nodes and look up where they are running. Seed Secret Signer Scheduler","title":"Overview"},{"location":"getting-started/#overview","text":"Before diving into the specifics, let's first define a number of concepts that will be useful once we start developing:","title":"Overview"},{"location":"getting-started/#nodes","text":"Greenlight provisions and manages Core Lightning nodes on behalf of its users. The nodes expose the grpc interface defined in the cln-grpc proto file , without limitations. The goal of this guide is to spin up a node and interact with it as if it were a local Core Lightning node.","title":"Nodes"},{"location":"getting-started/#authentication","text":"All communication channels in Greenlight are authenticated and encrypted via mTLS (mutual Transport Layer Security), similar to HTTPS in the browser. Each client receives its own identity in the form of a private key and matching certificate, which can then be used to authenticate and encrypt communication when talking with Greenlight. In this guide we will be using two identities: nobody : An identity that is shipped with the library, used to communicate with services that don't require authentication. A Device Identity: A unique identity used by the application to authenticate with the Greenlight. The private key is generated and kept locally, and certified by Greenlight to belong to a given node. See the security page for more details about how the authentication works.","title":"Authentication"},{"location":"getting-started/#signer","text":"The signer manages any private information, is used to prove node ownership when registering and recovering, and processes signature requests from the node. It is initialized with the secret seed (a 32 byte secret), the bitcoin network the node runs on, and the identity to use when communicating with the node. See the security page for details on how the signer ensures that operations it signs off originate from an authenticated app.","title":"Signer"},{"location":"getting-started/#scheduler","text":"Node in Greenlight are scheduled on-demand when a client needs to talk to it. The Scheduler tracks which nodes are running where, and starts them if they aren't running yet. You can think of it as just a mechanism to register new nodes and look up where they are running. Seed Secret Signer Scheduler","title":"Scheduler"},{"location":"getting-started/installation/","text":"Installing the library Greenlight provides client libraries for a variety of programming languages, providing an idiomatic interface to developers. The libraries allow interaction with both the Scheduler and the Node . The Scheduler provides access to the node metadata, while the Node is the user's CLN node running on Greenlight's infrastructure. Steps to install the library depend on the programming language and target environment. The code blocks below provide tabs for the most common ones: Rust Python Javascript Add the gl-client crate as a dependency: [dependencies] gl-client = { git = \"ssh://git@github.com/Blockstream/greenlight\" } The python library currently resides on a private repository which has to be specified during the installation: pip install \\ --extra-index-url = https://us-west2-python.pkg.dev/c-lightning/greenlight-pypi/simple/ \\ -U glcli The javascript library currenctly resides on a private repository, which needs to be configured the first time you install it: npm config set @greenlight:registry = https://us-west2-npm.pkg.dev/c-lightning/test-npm/ Afterwards specifying the namespace @greenlight is sufficient to install from the private repository. npm install @greenlight/gl-client-js","title":"Installation"},{"location":"getting-started/installation/#installing-the-library","text":"Greenlight provides client libraries for a variety of programming languages, providing an idiomatic interface to developers. The libraries allow interaction with both the Scheduler and the Node . The Scheduler provides access to the node metadata, while the Node is the user's CLN node running on Greenlight's infrastructure. Steps to install the library depend on the programming language and target environment. The code blocks below provide tabs for the most common ones: Rust Python Javascript Add the gl-client crate as a dependency: [dependencies] gl-client = { git = \"ssh://git@github.com/Blockstream/greenlight\" } The python library currently resides on a private repository which has to be specified during the installation: pip install \\ --extra-index-url = https://us-west2-python.pkg.dev/c-lightning/greenlight-pypi/simple/ \\ -U glcli The javascript library currenctly resides on a private repository, which needs to be configured the first time you install it: npm config set @greenlight:registry = https://us-west2-npm.pkg.dev/c-lightning/test-npm/ Afterwards specifying the namespace @greenlight is sufficient to install from the private repository. npm install @greenlight/gl-client-js","title":"Installing the library"},{"location":"getting-started/recover/","text":"","title":"Recover access"},{"location":"getting-started/register/","text":"Register a node Preparing a node identity We start by creating a node identity, consisting of a node's seed secret, and it's mTLS certificates we'll later use to authenticate against Greenlight. Let's start with the seed secret: the seed secret is a 32 byte secret that all other secrets and private keys are derived from, as such it is paramount that this secret never leaves your device and is only handled by the Signer . It is suggested to derive the seed secret from a BIP 39 seed phrase, so the user can back it up on a physical piece of paper, steel plate, or whatever creative way of storing it they can think of. Rust Python Install the bip39 and rand crates required for secure randomness and conversion of mnemonics. Add the following lines to your Cargo.toml [dependencies] rand = \"*\" bip39 = \"*\" Install the bip39 package which we'll use to encode the seed secret as a seed phrase: pip install bip39 Now we can securely generate some randomness, encode it as BIP 39 phrase and then convert it into a seed secret we can use: Rust Python Javascript use bip39 :: { Mnemonic , Language }; let mut rng = rand :: thread_rng (); let m = Mnemonic :: generate_in_with ( & mut rng , Language :: English , 24 ). unwrap (); let phrase = m . word_iter (). fold ( \"\" . to_string (), | c , n | c + \" \" + n ); # Prompt user to safely store the phrase seed = m . to_seed ( \"\" )[ 0 .. 32 ] # Only need the first 32 bytes # Store the seed on the filesystem , or secure configuration system import bip39 import secrets # Make sure to use cryptographically sound randomness rand = secres . randbits ( 256 ) # 32 bytes of randomness phrase = bip39 . encode_bytes ( rand ) # Prompt user to safely store the phrase seed = bip32 . phrase_to_seed ( phrase )[: 32 ] # Only need 32 bytes # Store the seed on the filesystem, or secure configuration system Next we instantiate an mTLS identity we will use to authenticate with Greenlight. Since we haven't registered our node with the service yet, we will use a dummy key, that allows us to talk to the Scheduler but will not allow us to talk to any other service. No worries, once we register the node we will get a valid certificate to authenticate. Rust Python Javascript use gl_client :: tls :: TlsConfig ; let tls = TlsConfig :: new (); from glclient import TlsConfig # Creating a new `TlsConfig` object will automatically load the dummy identity tls = TlsConfig () const glclient = require ( 'glclient' ); # Creating a new `TlsConfig` object will automatically load the dummy identity var tls = new glclient . TlsConfig (); Finally, we can create the Signer which processes incoming signature requests, and is used when registering a node to prove ownership of the private key. The last thing to decide is which network we want the node to run on. You can chose between the following networks: testnet bitcoin We'll pick bitcoin , because ... reckless \ud83d\ude09 Rust Python Javascript use gl_client :: signer :: Signer ; use bitcoin :: Network ; signer = Signer :: new ( secret , Network :: Bitcoin , tls ) Registering a new node Registering a node with the Scheduler creates the node metadata on the Greenlight service, including the node's identity and the public key, and ensures everything is setup to start the node. In order to register a node, the client needs to prove it has access to the corresponding private key. Since the private key is managed exclusively by the Signer we need to first instantiate that: Python from glclient import TlsConfig , Signer , Scheduler # Create an mTLS identity using the default `nobody` identity, allowing us # to talk to the Scheduler tls = TlsConfig () # The seed secret used for the identity. You most likely want secret = b ' \\x00 ' * 32 TODO: - Store secret on fs - Add code to load from fs - what to do with the result - Store cert and key on disk","title":"Registering a node"},{"location":"getting-started/register/#register-a-node","text":"","title":"Register a node"},{"location":"getting-started/register/#preparing-a-node-identity","text":"We start by creating a node identity, consisting of a node's seed secret, and it's mTLS certificates we'll later use to authenticate against Greenlight. Let's start with the seed secret: the seed secret is a 32 byte secret that all other secrets and private keys are derived from, as such it is paramount that this secret never leaves your device and is only handled by the Signer . It is suggested to derive the seed secret from a BIP 39 seed phrase, so the user can back it up on a physical piece of paper, steel plate, or whatever creative way of storing it they can think of. Rust Python Install the bip39 and rand crates required for secure randomness and conversion of mnemonics. Add the following lines to your Cargo.toml [dependencies] rand = \"*\" bip39 = \"*\" Install the bip39 package which we'll use to encode the seed secret as a seed phrase: pip install bip39 Now we can securely generate some randomness, encode it as BIP 39 phrase and then convert it into a seed secret we can use: Rust Python Javascript use bip39 :: { Mnemonic , Language }; let mut rng = rand :: thread_rng (); let m = Mnemonic :: generate_in_with ( & mut rng , Language :: English , 24 ). unwrap (); let phrase = m . word_iter (). fold ( \"\" . to_string (), | c , n | c + \" \" + n ); # Prompt user to safely store the phrase seed = m . to_seed ( \"\" )[ 0 .. 32 ] # Only need the first 32 bytes # Store the seed on the filesystem , or secure configuration system import bip39 import secrets # Make sure to use cryptographically sound randomness rand = secres . randbits ( 256 ) # 32 bytes of randomness phrase = bip39 . encode_bytes ( rand ) # Prompt user to safely store the phrase seed = bip32 . phrase_to_seed ( phrase )[: 32 ] # Only need 32 bytes # Store the seed on the filesystem, or secure configuration system Next we instantiate an mTLS identity we will use to authenticate with Greenlight. Since we haven't registered our node with the service yet, we will use a dummy key, that allows us to talk to the Scheduler but will not allow us to talk to any other service. No worries, once we register the node we will get a valid certificate to authenticate. Rust Python Javascript use gl_client :: tls :: TlsConfig ; let tls = TlsConfig :: new (); from glclient import TlsConfig # Creating a new `TlsConfig` object will automatically load the dummy identity tls = TlsConfig () const glclient = require ( 'glclient' ); # Creating a new `TlsConfig` object will automatically load the dummy identity var tls = new glclient . TlsConfig (); Finally, we can create the Signer which processes incoming signature requests, and is used when registering a node to prove ownership of the private key. The last thing to decide is which network we want the node to run on. You can chose between the following networks: testnet bitcoin We'll pick bitcoin , because ... reckless \ud83d\ude09 Rust Python Javascript use gl_client :: signer :: Signer ; use bitcoin :: Network ; signer = Signer :: new ( secret , Network :: Bitcoin , tls )","title":"Preparing a node identity"},{"location":"getting-started/register/#registering-a-new-node","text":"Registering a node with the Scheduler creates the node metadata on the Greenlight service, including the node's identity and the public key, and ensures everything is setup to start the node. In order to register a node, the client needs to prove it has access to the corresponding private key. Since the private key is managed exclusively by the Signer we need to first instantiate that: Python from glclient import TlsConfig , Signer , Scheduler # Create an mTLS identity using the default `nobody` identity, allowing us # to talk to the Scheduler tls = TlsConfig () # The seed secret used for the identity. You most likely want secret = b ' \\x00 ' * 32 TODO: - Store secret on fs - Add code to load from fs - what to do with the result - Store cert and key on disk","title":"Registering a new node"},{"location":"getting-started/schedule/","text":"Starting a node Now that the node has been registered on the Greenlight server, we can schedule it. Scheduling will tell the scheduler that we want to interact with the node, and need its GRPC URI, so we can talk to it. The scheduler will look up the node, check if it is currently running, and if not it'll start the node. It will then return the URL you can use to connect to the node directly. Important Currently nodes will get a new address whenever they are started, so don't cache the URL for longer periods of time. We spin nodes down if there is no client talking to it, and slots are reused for other nodes. Attempting to talk to a node that isn't yours will fail to establish a connection. The Greenlight team is working on an improvement that will assign a unique address to each node, ensuring that you always know how to reach the node, and allowing you to skip talking with the scheduler altogether. First of all we build an instance of the scheduler service stub, which will allow us to call methods on the service. We then schedule the node, which returns a stub representing the node running on the Greenlight infrastructure: Rust Python Javascript use hex ; let node_id = hex :: decode ( \"02058e8b6c2ad363ec59aa136429256d745164c2bdc87f98f0a68690ec2c5c9b0b\" ) ? ; let network = \"testnet\" ; let scheduler = gl_client :: scheduler :: Scheduler ( node_id , network ) ? ; let node = scheduler . schedule () ? ; from glclient import TlsConfig , Scheduler , cert , key = b '...' , b '...' node_id = bytes . fromhex ( \"02058e8b6c2ad363ec59aa136429256d745164c2bdc87f98f0a68690ec2c5c9b0b\" ) network = \"testnet\" tls = TlsConfig . with_identity ( cert , key ) scheduler = Scheduler ( node_id , network , tls ) node = scheduler . node () Once we have an instance of the Node we can start interacting with it via the GRPC interface: Rust Python Javascript","title":"Starting a node"},{"location":"getting-started/schedule/#starting-a-node","text":"Now that the node has been registered on the Greenlight server, we can schedule it. Scheduling will tell the scheduler that we want to interact with the node, and need its GRPC URI, so we can talk to it. The scheduler will look up the node, check if it is currently running, and if not it'll start the node. It will then return the URL you can use to connect to the node directly. Important Currently nodes will get a new address whenever they are started, so don't cache the URL for longer periods of time. We spin nodes down if there is no client talking to it, and slots are reused for other nodes. Attempting to talk to a node that isn't yours will fail to establish a connection. The Greenlight team is working on an improvement that will assign a unique address to each node, ensuring that you always know how to reach the node, and allowing you to skip talking with the scheduler altogether. First of all we build an instance of the scheduler service stub, which will allow us to call methods on the service. We then schedule the node, which returns a stub representing the node running on the Greenlight infrastructure: Rust Python Javascript use hex ; let node_id = hex :: decode ( \"02058e8b6c2ad363ec59aa136429256d745164c2bdc87f98f0a68690ec2c5c9b0b\" ) ? ; let network = \"testnet\" ; let scheduler = gl_client :: scheduler :: Scheduler ( node_id , network ) ? ; let node = scheduler . schedule () ? ; from glclient import TlsConfig , Scheduler , cert , key = b '...' , b '...' node_id = bytes . fromhex ( \"02058e8b6c2ad363ec59aa136429256d745164c2bdc87f98f0a68690ec2c5c9b0b\" ) network = \"testnet\" tls = TlsConfig . with_identity ( cert , key ) scheduler = Scheduler ( node_id , network , tls ) node = scheduler . node () Once we have an instance of the Node we can start interacting with it via the GRPC interface: Rust Python Javascript","title":"Starting a node"},{"location":"reference/","text":"Overview","title":"Overview"},{"location":"reference/#overview","text":"","title":"Overview"},{"location":"reference/node-rpc-proxy/","text":"","title":"Node RPC Proxy"},{"location":"reference/security/","text":"Security Client \u21c4 Node authentication Client \u21c4 Signer authentication","title":"Security"},{"location":"reference/security/#security","text":"","title":"Security"},{"location":"reference/security/#client-node-authentication","text":"","title":"Client &rlarr; Node authentication"},{"location":"reference/security/#client-signer-authentication","text":"","title":"Client &rlarr; Signer authentication"},{"location":"tutorials/","text":"Tutorials","title":"Overview"},{"location":"tutorials/#tutorials","text":"","title":"Tutorials"},{"location":"tutorials/self-hosting/","text":"Self-Hosting Your Node It is our goal to help you get started with the Lightning Network. However once you learned all that is required to run your own node, it is time to level up and approach the next challenge: managing your own node. For this purpose Greenlight allows users to export their nodes and restore it on their own infrastructure. This process can take a couple of minutes to complete, but it is faster and cheaper than migrating by shutting down the old node on GL, transferring all your funds, and having to bootstrap a new node from scratch. Under the hood we will: Mark the node as exported, so it doesn't start on GL going forward. Initiate a DB backup of the node's wallet database. Encrypt the DB backup so that it can be decrypted only by users that have access to the seed phrase. Store the encrypted backup on a file store, from where it can be downloaded, decrypted and restored locally by the user. Notice that step 1, marking the node as not-schedulable, is important for the security of the funds: if the node on GL were allowed to make progress it'd invalidate the backup, which could lead to channel closures. Setup Your Infrastructure Before initiating the export, we will first need to prepare the new home where the node will be running going forward. The node running on Greenlight is a slightly modified Core Lightning node, with some of custom subdaemons and plugins. You can chose to replicate the same node by also running the custom subdaemons and plugins, or you can run a vanilla Core Lightning node. Custom components include the following: signerproxy subdaemon: exposes the signer interface to the signer, enabling the remote signer setup. gl-plugin plugin: exposes the plugin interface, including mTLS verification, and acts as a tailable signer request stream. If you'd like to continue using the remote signer you should use both gl-plugin and signerproxy in your own setup as well. If not you will have to create the hsm_secret file in the CLN config directory so that the stock CLN signer can find it and use it to run a local-only signer. If you have any clients configured you'll likely want to run the gl-plugin rather than the stock grpc-plugin , as the former implements a superset of the latter. In addition clients will still be able to reach the node through the node URL through the GL reverse proxy . In the next sections we provide step-by-step instructions to restore the node's database, and then setup the different variants. You will have to decide which one best suites your needs :wink: Restoring the database Remote Signer Setup Local Signer Setups Minimal Setup The minimal setup to host an exported node consists of a PostgreSQL database, and a CLN installation matching or newer than the version that was running on Greenlight. Assuming the database is running locally with the credentials pguser and pgpass you' you'll have to run CLN node like this: lightningd --wallet = postgres://pguser:pgpass@localhost:5432/dbname Initiate Export The export can be triggered via the Scheduler.export_node method on the Scheduler's grpc interface . This method call may take a couple of minutes depending on the age of the node, the number of channels opened and closed, as well as the number of payments sent and received. Upon successful export the call will return a URL from a file host where the encrypted backup can be downloaded. Warning Once the state of the node has been switched you will no longer be able to schedule the node on Greenlight's infrastructure. We do not allow re-activating the node because of the risk of a replica running somewhere else, which could cause loss of funds! Do not worry if the connection is lost during this process, as the method is idempotent and will complete in the background if the connection is lost. Calling the method multiple times will results in the same encrypted backup URL","title":"Self-Hosting"},{"location":"tutorials/self-hosting/#self-hosting-your-node","text":"It is our goal to help you get started with the Lightning Network. However once you learned all that is required to run your own node, it is time to level up and approach the next challenge: managing your own node. For this purpose Greenlight allows users to export their nodes and restore it on their own infrastructure. This process can take a couple of minutes to complete, but it is faster and cheaper than migrating by shutting down the old node on GL, transferring all your funds, and having to bootstrap a new node from scratch. Under the hood we will: Mark the node as exported, so it doesn't start on GL going forward. Initiate a DB backup of the node's wallet database. Encrypt the DB backup so that it can be decrypted only by users that have access to the seed phrase. Store the encrypted backup on a file store, from where it can be downloaded, decrypted and restored locally by the user. Notice that step 1, marking the node as not-schedulable, is important for the security of the funds: if the node on GL were allowed to make progress it'd invalidate the backup, which could lead to channel closures.","title":"Self-Hosting Your Node"},{"location":"tutorials/self-hosting/#setup-your-infrastructure","text":"Before initiating the export, we will first need to prepare the new home where the node will be running going forward. The node running on Greenlight is a slightly modified Core Lightning node, with some of custom subdaemons and plugins. You can chose to replicate the same node by also running the custom subdaemons and plugins, or you can run a vanilla Core Lightning node. Custom components include the following: signerproxy subdaemon: exposes the signer interface to the signer, enabling the remote signer setup. gl-plugin plugin: exposes the plugin interface, including mTLS verification, and acts as a tailable signer request stream. If you'd like to continue using the remote signer you should use both gl-plugin and signerproxy in your own setup as well. If not you will have to create the hsm_secret file in the CLN config directory so that the stock CLN signer can find it and use it to run a local-only signer. If you have any clients configured you'll likely want to run the gl-plugin rather than the stock grpc-plugin , as the former implements a superset of the latter. In addition clients will still be able to reach the node through the node URL through the GL reverse proxy . In the next sections we provide step-by-step instructions to restore the node's database, and then setup the different variants. You will have to decide which one best suites your needs :wink:","title":"Setup Your Infrastructure"},{"location":"tutorials/self-hosting/#restoring-the-database","text":"","title":"Restoring the database"},{"location":"tutorials/self-hosting/#remote-signer-setup","text":"","title":"Remote Signer Setup"},{"location":"tutorials/self-hosting/#local-signer-setups","text":"","title":"Local Signer Setups"},{"location":"tutorials/self-hosting/#minimal-setup","text":"The minimal setup to host an exported node consists of a PostgreSQL database, and a CLN installation matching or newer than the version that was running on Greenlight. Assuming the database is running locally with the credentials pguser and pgpass you' you'll have to run CLN node like this: lightningd --wallet = postgres://pguser:pgpass@localhost:5432/dbname","title":"Minimal Setup"},{"location":"tutorials/self-hosting/#initiate-export","text":"The export can be triggered via the Scheduler.export_node method on the Scheduler's grpc interface . This method call may take a couple of minutes depending on the age of the node, the number of channels opened and closed, as well as the number of payments sent and received. Upon successful export the call will return a URL from a file host where the encrypted backup can be downloaded. Warning Once the state of the node has been switched you will no longer be able to schedule the node on Greenlight's infrastructure. We do not allow re-activating the node because of the risk of a replica running somewhere else, which could cause loss of funds! Do not worry if the connection is lost during this process, as the method is idempotent and will complete in the background if the connection is lost. Calling the method multiple times will results in the same encrypted backup URL","title":"Initiate Export"},{"location":"tutorials/standalone-signer/","text":"","title":"Standalone signer"},{"location":"tutorials/testing/","text":"","title":"Testing your app"}]}